---
title: "regis"
author: "regis andreoli"
date: "1/31/2022"
output:
  html_document:
    toc: yes
    toc_float: no
    toc_depth: 4
    number_sections: yes
  pdf_document:
    toc: yes
    toc_depth: '4'
---

````{r, echo= FALSE}
# load library
library(rstudioapi)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(caret)
library(GGally)
library(mgcv)
library(lubridate)
```

# Load Data
````{r, echo=FALSE}
# identify and set directory, then read data from csv
setwd(dirname(getActiveDocumentContext()$path))
df_weather <- read.csv("./data/weather.csv",header=TRUE,sep =",",comment.char ="#")
df_plantA <- read.csv("./data/A.csv",header=TRUE,sep =",",comment.char ="#")
df_plantB <- read.csv("./data/B.csv",header=TRUE,sep =",",comment.char ="#")
df_plantC <- read.csv("./data/C.csv",header=TRUE,sep =",",comment.char ="#")
`````

# Data preparation
```{r}
df_weather$local_time <- as.POSIXct(df_weather$local_time,tz="GMT",format="%Y-%m-%d %H:%M")
df_plantA$Timestamp <- as.POSIXct(df_plantA$Timestamp,tz="GMT",format="%Y-%m-%d %H:%M:%S")
df_plantB$Timestamp <- as.POSIXct(df_plantB$Timestamp,tz="GMT",format="%Y-%m-%d %H:%M:%S")
df_plantC$Timestamp <- as.POSIXct(df_plantC$Timestamp,tz="GMT",format="%Y-%m-%d %H:%M:%S")
#df_weather %>% rename(datetime = local_time,)
```

```{r}
df_plantA_resample <- df_plantA %>%
  mutate(datetime = floor_date(Timestamp, "1 hour")) %>%
  group_by(datetime) %>%
  summarise(across(Generation_kW:Overall_Consumption_Calc_kW, sum))

str(df_plantA_resample)
```

#Visual analysis
First visual analysis of the data. complemented by a gam smoother.
```{r}
ggplot(data = df_plantA_resample,
  mapping = aes(y = Generation_kW, x = datetime)) +
  geom_point(size = 1, color = "grey69") +
  geom_smooth(method = "gam", color = "cornflowerblue")
```

# Time Series Analysis
Convert data set into time series object. As the data has an hourly resolution, the time repetition interval is set to 24, which correspond to a seasonality of one day.
```{r}
library(forecast)

ts_1 <- ts((df_plantA_resample$Generation_kW), deltat = 1/24)
train <- window(ts_1, start = 1, end = 250)
fit <- auto.arima(train)
```

Plot the time series with the prediction.
```{r}
fc <- predict(fit, n.ahead = 115*24)
plot(ts_1, lty=3, size = 0.1)
lines(train, lwd=1)
lines(fc$pred, lwd=2, col="red", size = 0.01)
#lines(fc$pred+fc$se*1.96, col="red")
#lines(fc$pred-fc$se*1.96, col="red")
```

Plot the decomposition of the time series with the function stl().
```{r}
decomp<-stl(ts_1, s.window = 1/24, t.window = 365)
plot(decomp)
```


# Second Time Series Analysis - Manipulated Data
Some artificial years are added to the time series, to be able to capture the seasonal effects of the year.

## Data preparation
```{r}
df_plantA_resample_2 <- df_plantA %>%
  mutate(datetime = floor_date(Timestamp, "24 hour")) %>%
  group_by(datetime) %>%
  summarise(across(Generation_kW:Overall_Consumption_Calc_kW, sum))

ts_2 <- ts((df_plantA_resample_2$Generation_kW), start = c(2019), deltat = 1/365)
```

Plot time series of one year with a gam smoother.
```{r}
ggplot(data = df_plantA_resample_2,
  mapping = aes(y = Generation_kW, x = datetime)) +
  geom_point(size = 1, color = "grey69") +
  geom_smooth(method = "gam", color = "cornflowerblue")
```

Add random noise to first time series, in order togenerate new artificial years.
```{r}
ts_artif_1 <- {jitter(ts_2, factor=500, amount = NULL)}
ts_artif_2 <- {jitter(ts_2, factor=500, amount = NULL)}
head(ts_2)
head(ts_artif_1)
head(ts_artif_2)
```

Set negative values to zero, as due to the nature of the data, negative values cannot occur.
```{r}
ts_artif_1[][ts_artif_1[] < 0] <- 0
ts_artif_2[][ts_artif_2[] < 0] <- 0
```

Create time series of several years, starting with real data year and two artificial years.
```{r}
ts_artificial <- ts(c(ts_2, ts_artif_1, ts_artif_2), start = c(2019), deltat = 1/365)
str(ts_artificial)
```

Plot decomposition of the time series with the function stl().
```{r}
decomp<-stl(ts_artificial, s.window = 365)
plot(decomp)
```

Train model with the first two years of the time series. To train the model, the auto.arima function is made use of.
```{r}
train_2 <- window(ts_artificial, start = 2019, end = 2020)
fit_2 <- auto.arima(train_2)
```


# Artificial time series - new attemp: use of gam smoother as base and add normally distributed noise.

Create new data frame with indexed data. This is done to avoid date handling
```{r}
df_artif <- data.frame(time = (1:365), generation_kw = df_plantA_resample_2$Generation_kW)
```

Compute a smoother line function with the new data frame
```{r}
gam_model <- gam(generation_kw ~ s(time), data = df_artif)
```

Get the discrete steps from the smoother line by computing prediction in the desired step interval. The result is plotted to visually control the results. As shown below, the data frame plot is, at least qualitatively, very similar to the ggplot gam smoother line. This result will now be taken as smoothed year. 
```{r}
df_time <- data.frame(time = c(1:365))
gam_prediciton <- predict(gam_model, newdata = df_time)
plot(gam_prediciton, cex = 0.1, )
```
After the creation of an artificial "smoothed" year, noise is added. In order to keep the heteroskedastic behavior of the real data, the noise is added as a multiplication of a random coefficient. After trying around, the random coefficient are created with values between 0.2 to 1. A quick look at the plot show a satisfying result.

Add noise to smoothed base year
```{r}
library(BBmisc)
library(fGarch)
set.seed(1)
random_coef <- rsnorm(365, mean = 1, sd = 1, xi = 0.1)
ran_coef_norm <- normalize(random_coef, method = "range", range = c(0, 1))
#ran_coef_norm <- ran_coef_norm * 1.3
ran_coef_norm_2 <- ran_coef_norm * runif(ran_coef_norm, min = 0.3, max = 1.6)
base_y_with_noise <- gam_prediciton * ran_coef_norm_2

mean(df_plantA_resample_2$Generation_kW)
median(df_plantA_resample_2$Generation_kW)
hist(df_plantA_resample_2$Generation_kW, breaks = 11)

mean(gam_prediciton)
median(gam_prediciton)
hist(gam_prediciton, breaks = 11)

hist(ran_coef_norm)

mean(base_y_with_noise)
median(base_y_with_noise)
plot(base_y_with_noise, cex = 0.2)
hist(base_y_with_noise, breaks = 11)
```

While the artificial year visually looks satisfying, the mean generally is too low. It is not easy to change the noise parameters in such a way, that the variance and the mean of the artificial year gets near a similar value of the real data. Therefore, a function is create which aims to find the best parameter setting:

First, a list of parameter sets is created. This list is then used in a function that loops through the list and creates for each set a noised year. The noised year is then compared with the real year by its mean and variance. A threshold for mean and variance is set. As soon as the thresholds are cumulatively fulfilled, the function stops and passed the noised year as an output of the function.
```{r}
#create list of parameter sets
library(BBmisc)
xi <- c(20:1)/20
min <- c(1:20)/50
max <- c(50:70)/40
u <- list()
  for (i in xi) {
    for (n in min) {
      for (q in max) {
        o <- c(i, n, q)
        u <- rbind(u,o)
      }
    }
  }
```

```{r}
get_artificial_list <- function(mean_real_yr, variance_real_yr, gam_prediciton) {
  
  div_mean <- 0
  div_var <- 0
  i = i
  treshold_1 <- TRUE
  treshold_2 <- TRUE
  df_sets <- list()
  
  for (n in u) {
    
    random_coef <- rsnorm(365, mean = 1, sd = 1, xi = as.numeric(u[i,][1]))
    ran_coef_norm <- normalize(random_coef, method = "range", range = c(0, 1))
    ran_coef_norm_2 <- ran_coef_norm * runif(ran_coef_norm, min = as.numeric(u[i,][2]), max = as.numeric(u[i,][3]))

    yr_with_noise <- gam_prediciton * ran_coef_norm_2
    div_mean <- (mean_real_yr / mean(yr_with_noise))
    div_var <- (variance_real_yr / var(yr_with_noise))
       
    treshold_1 <- (div_mean > 1.05 | div_mean < 0.95)
    treshold_2 <- (div_var > 1.1 | div_var < 0.9)
    
    if (treshold_1 && treshold_2){
    df_sets <- rbind(df_sets, yr_with_noise)
    }
    
    print(i)
    #print(div_mean)
    #print(div_var)
    #print(mean(yr_with_noise))
    i <- i + 1
  }
  df_sets
}

```


```{r}
mean_real <- mean(df_plantA_resample_2$Generation_kW)
var_real <- var(df_plantA_resample_2$Generation_kW)

noised_year <- get_artificial_list(mean_real, var_real, gam_prediciton)
plot(noised_year, cex = 0.1)
```
















